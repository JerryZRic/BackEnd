# 深入理解closure（闭包)

https://tour.golang.org/moretypes/25

小伙伴们在进行到这里时，会遇到这个Function closures的章节。对于熟悉编程的小伙伴，可能知道中文叫做“闭包”，而“闭包”对编程初学者而言一直是个神秘的领域。那么，到底什么是闭包呢？

## 闭包为什么存在？

我们认为，闭包是语言设计中出现的一种副产品，其本身并没有什么特殊的意义。

### 函数是一等公民

`pos, neg := adder(), adder()`

闭包之所以产生，是由于Go语言“函数是一等公民”的性质，也就是说，在Go语言中，函数本身是一个普通的value，可以赋值给变量，可以作为参数传递给函数，可以完成一切其他普通value可以完成的事情。

这个性质，叫做“Functions as first-class citizens"（函数是一等公民）。具有这一特性的编程语言，函数和普通value之间并没有任何区别。

那么，既然函数可以作为变量传给函数，这里就出现了衍生效应：”Higher-order functions“（高阶函数）。

### 高阶函数

```
func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}
```

一个普通的函数，传入一些普通的值，然后返回一些普通的值。然而当一个函数可以传入其他函数，或者返回一个函数，或者既传入一个函数也返回一个函数，这个可以接收函数/返回函数的函数就叫做”高阶函数“。

相信小伙伴们一经发现，这是一个衍生概念，是”函数是一等公民“规则下的必然结果，其本身并没有什么特殊之处。

### 闭包

当一个函数返回一个函数，而被返回的函数如果使用了原函数中的变量，这就构成了一个闭包。在上面的代码示例中，被adder函数返回的函数使用了adder函数中的变量sum，那么被返回的这个函数每被执行一次，adder函数中的sum就会被加一。

通过这种方式被返回的函数，可以视作一个自带状态的函数，或者被贴上了数据的函数。这个函数每被执行一次，自带的内部状态（准确地说是返回这个函数的函数中的变量）都会发生变化，从而返回不同的值。

可以说，闭包是由于编程语言遵循了”函数是一等公民“规则下的必然结果，其本身并没有太大意义，我们可以通过逻辑推理来掌握闭包的性质。而在实际应用上也缺乏价值，一般而言明确地使用状态（而不是贴到某一个函数上）总是一个好主意。
